<!DOCTYPE html>
<html lang="fr">
  <head>
        <meta charset="UTF-8" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta name="author" content="Maëlle Broustal - Florian Dupeuble - Aurélie Fischer - Nicolas Mendiboure" />
        <meta name="description" content="">

        <title id="Description">La Maladie d'alzheimer - Projet 3BIM</title>

        <link type="text/css" rel="stylesheet" href="Alzheimer_Website.css" />
        <!-- Bootstrap core CSS -->
        <link href="./styles/bootstrap.min.css" rel="stylesheet">
        <!-- jQWidgets CSS -->
        <link href="./jqwidgets/styles/jqx.base.css" rel="stylesheet">
        <link href="./jqwidgets/styles/jqx.bootstrap.css" rel="stylesheet">
        <link href="./prism.css" rel="stylesheet" />

	<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
	<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

  </head>
  <header>
	<div id="onglet_page">
		<div class="onglet" id="projet">
			<a href="Alz.html"><h1 class="police_onglet">Projet</h1></a>
		</div>
		<div class="onglet" id="bio">
			<a href="Alz_Bio.html"><h1 class="police_onglet">Biologie</h1></a>
		</div>
		<div class="onglet onglet_actuel" id="mod">
			<a href="Alz_Mod.html"><h1 class="police_onglet">Modélisation</h1></a>
		</div>
		<div class="onglet" id="maths">
			<a href="Alz_Maths.html"><h1 class="police_onglet">Mathématiques</h1></a>
		</div>
	</div>
  </header>
  <body>
    <!-- Wrap all page content here -->
    <div id="wrap">
       <!-- Fixed navbar -->
       <div class="navbar navbar-default navbar-fixed-top" role="navigation">
          <div class="container">
             <div style="visibility: hidden;" id="navBar" >
                <ul>
                   <li>
                      <a href="#">Menu</a>
                      <ul style="width: 400px;">
                         <li><a href="Alz.html#ancre1">Présentation du projet</a></li>
                         <li type="separator"></li>
                         <li><a href="Alz_Bio.html#ancre2">Introduction à la biologie d'Alzheimer</a></li>
                         <li><a href="Alz_Bio.html#ancre3"> - La protéine Béta-Amyloide</a></li>
                         <li><a href="Alz_Bio.html#ancre4"> - La protéine Tau</a></li>
                         <li><a href="Alz_Bio.html#ancre5"> - La formation d'agregats</a></li>
                         <li type="separator"></li>
                         <li><a href="Alz_Bio.html#ancre6"> - Les solutions thérapeutiques existantes</a></li>
                         <li><a href="Alz_Mod.html#ancre7">Modélisations</a></li>
                         <li><a href="Alz_Mod.html#ancre8"> - Utilisation de l'individu centré</a></li>
                         <li><a href="Alz_Mod.html#ancre9"> - Logiciel Netlogo</a></li>
                         <li><a href="Alz_Mod.html#ancre10"> - Passage sur Python</a></li>
                         <li><a href="Alz_Mod.html#ancre11"> - La classe Protein </a></li>
                         <li><a href="Alz_Mod.html#ancre12"> - La classe Neuron </a></li>
                         <li><a href="Alz_Mod.html#ancre13"> - La classe BrainView </a></li>
                         <li><a href="Alz_Mod.html#ancre14"> - Difficultés rencontrées </a></li>
                         <li><a href="Alz_Mod.html#ancre15"> - Avec Python 3</a></li>
                         <li><a href="Alz_Mod.html#ancre16"> - Première version </a></li>
                         <li><a href="Alz_Mod.html#ancre17"> - Deuxième version</a></li>
			 <li type="separator"></li>
			 <li><a href="Alz_Maths.html#ancre18">Mathématiques</a></li>
                         <li><a href="Alz_Maths.html#ancre19"> - Hypothèses du modèle et formulation </a></li>
                         <li><a href="Alz_Maths.html#ancre20"> - Formulation mathématique</a></li>


                         <li type="separator"></li>


                         <li><a href="Alz.html#ancre18">Bibliographie / Sources</a></li>
                         <li type="separator"></li>
                      </ul>
                   </li>
                   <li>
                      <a href="#about">à propos</a>
                      <ul style="width: 400px;">
                         <li>ligne d'explication N°1<br>
                            ligne d'explication N°2
                         </li>
                      </ul>
                   </li>
                   <li>
                      <a href="#contact">Contact</a>
                      <ul style="width: 400px;">
                        <li> 3ème année de bioinformatique </li>
                        <li> Biosciences, INSA Lyon </li>
                        <br>
                        <li>Maëlle Broustal </li>
                        <li> Florian Dupeuble </li>
                        <li> Aurélie Fischer </li>
                        <li> Nicolas Mendiboure </li>


                      </ul>
                   </li>
                </ul>
             </div>
             <!--/.nav-collapse -->
          </div>
       </div>

<!-- Begin page content -->

      <a id="ancre7"></a>
        <h2 class ="partie">Modélisations </h2>

      <a id="ancre8"></a>
        <h3 class = "sous-partie">I - Choix du type de modélisation : utilisation de l’individu centré </h3>


		<p> Une fois décidés de travailler sur la propagation de la maladie dans le cerveau, nous avons fait de nombreuses recherches sur les modélisations envisageables, notamment sur les modélisations de neurones. Ce qui nous a amenés aux réseaux de neurones. Nous avons orienté nos recherches dans cette direction mais nous sommes aperçus que, malgré son nom, cette technique n’est pas nécessairement adaptée pour modéliser le cerveau, sans compter sa complexité.
Etant à court d’idée, nous avons songé à demander de l’aide à des personnes connaissant le sujet. Une chance pour nous : de nombreux professeurs du département Biosciences ont travaillé sur Alzheimer. Nous avons contacté Laurent PUJO-MENJOUET que nous connaissions bien. Pendant une discussion, il nous a conseillé de nous tourner vers les modélisations automate-cellulaire et individu centré.
		</p>

    <p>
        La modélisation de l’automate cellulaire présente une grille de cellules pouvant prendre différents états. Leur état est amené à évoluer au cours du temps en répondant à certaines règles (ou fonctions d’état) identiques pour chaque cellule, reliées à l’état de leurs cellules adjacentes. Les règles s’appliquent à chaque itération temporelle.
        Un exemple célèbre de ce type de modélisation est le jeu de la vie. </p>

            <div id="jeu_vie">
              <div id="jeu_vie_video">

                <video controls width = "420" height ="420">
                    <source src="./Videos/Jeu_vie.webm" type="video/webm">
                </video>

                <h5 class="center small"> <b>Vidéo</b> : Exemple de jeu de la vie codé en java (openjdk-11)<h5>

              </div>

              <div id="jeu_vie_text">


    <p>
      Les cellules peuvent prendre deux états distincts : vie ou mort. Les règles sont les suivantes :
      “une cellule morte possédant exactement trois voisines vivantes devient vivante (elle naît) ;
      une cellule vivante possédant deux ou trois voisines vivantes le reste, sinon elle meurt.”
      Malgré sa simplicité, le jeu de la vie intéresse beaucoup de par les différents comportements pris par les cellules en fonction de l’état initial (structures stables, canons, vaisseaux…)
    </p>

    <p>
      L’individu centré est un système comportant des entités autonomes, ou individus, qui disposent d’informations, que nous appelons perceptions, sur leur environnement de façon localisée. De nouveau, certaines règles sont appliquées, ici aux individus. Elles vont les conduire à une action sur leur environnement.
      Il peut s’agir par exemple de déplacements ou d’affecter d’autres individus.
      De nombreux exemples existent, bien qu’aucun, sans doute, ne soit aussi célèbre que le jeu de la vie. Citons MobiSim, une modélisation pour l’analyse géographique et la mobilité des hommes.
    </p>

  </div>

</div>



<div class="textblock">
    <p>
      Nous avons choisi l’individu centré. En effet, il nous a semblé plus pertinent de considérer les protéines comme des agents, car celles-ci se déplacent dans le cerveau et s’agrègent. Avec un automate cellulaire, la grille aurait représenté le cerveau.
      Les différents états des cellules auraient été leur niveau de dégradation ou la présence d’agrégats à l’intérieur. Nous aurions assisté à une diffusion de la maladie. Avec une modélisation individu centré, il est à la fois possible d’assister à une diffusion de la maladie, mais en plus, d’avoir une idée précise de la façon dont se forment les agrégats.
      Nous pouvions aussi considérer les neurones comme d’autres individus qui produisent des protéines, ou encore d’autres éléments : par exemple, imaginer un produit aux effets divers sur les protéines (ralentissement, empêchement de s’agréger) et en observer les conséquences, ce qui pourrait aider dans l'élaboration d’un médicament.
      En résumé, l’individu centré nous donnait une plus grande liberté dans la modélisation, c’est pourquoi nous nous sommes tournés vers lui.
     </p>

    <p> Nous avons choisi de nous concentrer sur les protéines béta-Amyloïdes et laisser de côté les protéines Tau. Ainsi, les béta-Amyloïdes et les neurones seraient les individus de notre modélisation. Quels comportements souhaitions-nous implémenter ? </p>

    <p>
    Les <b> protéines</b> , représentées par des sphères de couleur, sont capables de se déplacer sur le “terrain”, dont nous explicitons les particularités plus loin. Leurs déplacements sont globalement rectilignes mais peuvent comporter de légères courbures aléatoires.
    Elles possèdent une faible <b>probabilité de devenir spontanément infectieuses</b>. Quand elles touchent d’autres protéines, elles se collent à elles et transmettent leur infection le cas échéant.
    Elles possèdent une faible <b>probabilité de se détacher spontanément </b>. Quand elles s’agrègent, leur vitesse de déplacement diminue (plus l’agrégat est important, plus leur vitesse ralentit).
    Quand elles touchent un neurone, elles affectent son état. </p>

    <p>
    Les <b>neurones</b>, également représentés par des sphères, sont immobiles sur le terrain.
    A chaque itération, ils possèdent une <b> probabilité d’expulser </b> une nouvelle protéine béta-Amyloïde non infectée.
    Ils possèdent une échelle d’états, allant de parfaitement fonctionnels à non fonctionnels. Au départ, ils sont parfaitement fonctionnels. Lorsqu’ils ne sont plus fonctionnels, ils ne peuvent plus expulser de nouvelles protéines. Ce sont les béta-Amyloïdes qui influencent leur état. </p>

    <p>
    Le <b>terrain</b>. Ce que nous appelons le terrain correspond ici à la matrice extracellulaire du cerveau dans laquelle se déplacent les protéines. Le problème de conception majeur vient des bords. Nous pouvons les considérer soit comme des frontières infranchissables pour les protéines ou, au contraire, considérer que l'on ne traite qu'une zone restreinte du cerveau. Dans ce second cas, certaines protéines peuvent s’échapper de la zone et accéder au restant du cerveau, tandis que d'autres peuvent rentrer dans la zone modélisée. Le premier cas pose problème d’un point de vue de design : il est difficile d’imaginer que les protéines rencontrent ainsi des murs. Bien que le cerveau soit limité, la taille des protéines est très faible devant le volume du cerveau, et la fréquence de rencontre avec des “murs” est sans doute infime. Le deuxième cas pose problème d’un point de vue implémentation : si nous considérons que les protéines peuvent quitter le terrain de la simulation, nous avons peu de chances de les observer s’agréger (à moins d’une taille de terrain énorme). Même si de nouvelles protéines peuvent entrer sur le terrain, cela ne suffira pas, car le problème vient des agrégats qui quittent le terrain. Nous avons pensé à poser une probabilité qu’un agrégat entre dans le terrain à chaque itération, mais cela allait à l’encontre de l’un des objectifs de notre modélisation : observer comment se forment les agrégats.
    Une solution alternative était de considérer le terrain comme une coupe 2D non plane du cerveau. Prenons l’exemple d’une coupe cylindrique, que nous couperions dans le sens de la hauteur et mettrions à plat.
    </p>

  </div>

  <div id="cylindre">
    <div id="cylindre_im">
        <img src="Images/cylindre.PNG" width = 80% >
    </div>
    <div id="cylindre_text">


    <p>
    Dans ce cas, les protéines allant sur l’un des bords en pointillés se retrouvent de l’autre côté à la même hauteur. Là encore, nous rencontrons un problème de design : est-il vraiment pertinent d’envisager notre terrain comme une coupe non plane du cerveau ?
    En réalité, notre groupe ne tombait pas d’accord sur la meilleure possibilité. Avant que le projet s’interrompe, nous considérions ce dernier cas pour des raisons pratiques, mais ce choix était amené à changer.
    </p>

    <p>
    Nous avons pensé à ajouter des individus correspondants à des substances hypothétiques, qui pourraient par exemple ralentir les béta-Amyloïdes, afin de découvrir quelles influences seraient bénéfiques pour le malade, dans l'optique de concevoir un médicament. Néanmoins, nous avons convenu que nous devions d’abord achever la modélisation des éléments précédents avant de rajouter de nouveaux types d’individus, et à condition que le délais restant soit suffisant. L’interruption du projet ne nous en a pas donné le temps.
    </p>

    </div>
  </div>


    <a id="ancre9"></a>
      <h3 class = "sous-partie">II- Avec le logiciel Netlogo : </h3>

    <p>
		Netlogo &copy est un logiciel gratuit et opensource muni de son propre language de programmation ainsi que d'un environnement de modélisation permettant de créer des systèmes multi-agents allant du modèle proies - prédateurs, au modèle simulant la construction d'un nid d'abeille ou bien le développement d'une tumeur. Ce logiciel nous a été suggéré par notre tuteur de projet M. Pujo-Menjouet. Le gros point fort de NetLogo &copy est qu'il est livré avec une très grande bibliothèque de modèles tous aussi variés les uns que les autres, nous permettant ainsi de nous en inspirer afin de ce  très vite comprendre et assimiler la syntaxe du language NetLogo et d'en ressortir une ébauche de premier modèle individu-centré, mettant en relation un neurone et les proteines béta-Amyloïdes qui s'agrègent autour de lui. Un autre point fort de Netlogo &copy est que son interface graphique est très intuitive à utiliser, ainsi il est très simple de mettre en relation le code et l'interface graphique, permettant notament de rajouter ou de modifier des paramètres en cours de simulation via l'interface utilisateur grâce à des curseurs ou des boutons.
    </p>


		      <img class="displayed" src="Images/Netlogo_WS.png" width = 60% > <!-- width = 750, height = 650 -->
		      <figcaption class="center"> Exemple de modèle proie - prédateur avec des moutons et des loups. </figcaption>

          <p class='small center'> <i>Source de l'image </i> : <a href=https://ccl.northwestern.edu/netlogo/models/WolfSheepPredation> https://ccl.northwestern.edu/netlogo/</a></p>

<table cellspacing="0" align="center">
    <tr height=50px>  </tr>
    <tr>
      <th>
          <h4 class="center"> Simulation avec NetLogo &copy : </h4>
      		<video controls width = "800" height ="500">
          		<source src="./Videos/NetLogo.webm" type="video/webm">
      		</video>

        </th>
    </tr>
    <tr height=50px>  </tr>
</table>

<h4 class="center"> Visualisation du code NetLogo &copy; : </h4>

<pre><code class="language-python">
breed [AB a-AB]
breed [neurone a-neurone]
AB-own [leader turn-amount]

to setup
  clear-all
  setup-neurone
  create-AB nb-AB-ini?
    [ set color red
      set shape "circle"
      setxy random-xcor random-ycor
      rt random-float 360
      ;; initially, every node leads its own cluster of one
      set leader self ]
  reset-ticks
end

to go
  ;; All the leaders choose turn amounts
  ask AB with [leader = self] [
    set turn-amount random 10 - random 10
  ]
  ;; All nodes follow their leaders
  ask AB [
    rt [turn-amount] of leader
    fd 0.1
  ]
  ;; Here's the tricky part. We check whether any pairs
  ;; of clusters are touching, and if they are, we merge them.
  ask AB [
    let candidates AB in-radius 1 with [leader != [leader] of myself]
    if any? candidates [
      create-links-with candidates [ hide-link ]
      ask candidates [ merge ]
    ]
  ]
  if random 1000 < 3 [
    create-AB 1 [
      set color yellow
      set shape "circle"
      setxy 0 0
      rt random-float 360
      set leader self
      ]
    ]
  tick
end

;; This is a recursive procedure -- it calls itself.
;; That way the new leader propagates through the entire
;; cluster.
to merge  ;; node procedure
  ;; First this node merges.
  set leader [leader] of myself
  set heading [heading] of leader
  set color blue
  ;; Then any neighboring nodes that haven't merged yet
  ;; merge.
  ask link-neighbors with [leader != [leader] of myself]
    [ merge ]
end

to setup-neurone
  create-neurone 1
  [
    setxy 0 0
    set color blue + 1
    set size 4
    set shape "leaf"
  ]
end
</code></pre>



    <a id="ancre10"></a>
        <h3 class = "sous-partie">III- Passage sur python </h3>

		<p> Nous avons défini trois classes python : la classe Protein, Neuron, et BrainView.</p>

      <a id="ancre11"></a>
        <h4 class = "python_class"> La classe Protein : </h4> <br>
		        <img src="Images/protein.PNG" width = 10% >


<br>

    <p> La classe Protein possède les attributs suivants : </p>
      <ul class="list">
        <li> x et y, ses coordonnées spatiales </li>
          <li>  r, son rayon </li>
            <li> direction, qui correspond à l’angle formé avec l’axe des x de la fenêtre de visualisation dans le sens des aiguilles d’une montre </li>
          <li> leader, qui est la Protein suivie par la Protein courante. Lors de son initialisation, le leader de la Protein est elle-même. L’intérêt de cet attribut, inspiré par l’implémentation sur NetLogo &copy, était d’avoir une Protein qui imposerait la direction à toutes celles qui composent le même agrégat qu’elle (et qui l’aurait comme leader). </li>
        <li> color, qui correspond à son état : normal ou infectieux. Lors de son initialisation, son état est normal, soit color == “yellow”. Dans son état infectieux, color ==”red”. </li>
      </ul>

<br>

<p>
  Parmi les méthodes importantes, on trouve :
  <ul class="list">
    <li> move : modification des x et y de la Protein grâce aux fonctions cos et sin appliquées au leader </li>
    <li> hook : si deux Protein se touchent, elles se collent. L’une devient leader. Nous pensons que les problèmes d’agrégations viennent de là. En effet, lorsque deux agrégats se croisent, il faut que toutes les Protein d’un des agrégats prennent comme leader le leader de l’autre agrégat. Cette attribution n’est pas totale.</li>
    <li> degrade : prend en argument un Neuron. S’ils se touchent, l’état du Neuron gagne 1. </li>
  </ul>
</p>

<h4 class="center"> Visualisation du code Python de la classe <i>Protein</i> : </h4>

<pre><code class="language-python">
import math as m
import cerveau as c
import neurone as n
import random as r


class Protein():
	def __init__(self, r, x, y, angle):
		self.r=r #r est le rayon de la proteine
		self.color="yellow"  #deux couleurs possibles : yellow = etat normal,  red = etat infectieux de la proteine
		#coordonnees de la proteine :
		self.x=x
		self.y=y
		self.leader=self #definie le leader (la proteine suivi) comme elle meme
		self.led=self #la protein qui la suit est elle meme
		self.direction=angle #la proteine se deplace selon un angle en degres

	def change_state(self, protein):
                #la proteine a une chance de changer d'etat toute seule et accrue si elle touche une proteine
		if r.random()< 0.0001:
			self.color="red"
		if self.distance(protein)<=self.r+protein.r and protein.color=="red":
                        #si une proteine en touche une autre qui est rouge, elle devient rouge
                        self.color="red"

	def move(self, c):
                if r.random()< 0.000001:
                        self.leader.leader.direction+=r.randint(1,5)
                        self.direction=self.leader.leader.direction
                #la proteine se deplace selon un angle (entier), elle doit suivre le leader
                self.x=self.x+int(10*m.cos(m.degrees(self.leader.leader.direction)))
                self.y=self.y+int(10*m.sin(m.degrees(self.leader.leader.direction)))

                if (self.x < 0) :
                    self.x = c.width
                elif (self.x > c.width) :
                    self.x = 0

                if (self.y < 0) :
                    self.y = c.height
                elif (self.y > c.height) :
                    self.y = 0


	def hook(self, protein):
                #deux proteines (d'etat evil seulement je crois) peuvent s'accrocher
                if self.distance(protein)<=protein.r+self.r :

                        self.leader.leader=protein.leader
                        self.leader=protein.leader
                        self.direction=protein.leader.direction


	def detach(self):
                #une proteine accrochee ont une probabilite de se decrocher
                #ce qui revient a tranformer le leader en elle meme
                if r.random()< 0.0000000000001:
                        self.leader=self

	def distance(self, cercle): #mesure la distance entre la proteine
                #et une autre proteine ou le neurone
                return m.sqrt((self.x-cercle.x)*(self.x-cercle.x)+(self.y-cercle.y)*(self.y-cercle.y))

	def degrade(self, neuron): #neuron est le tableau de neurones de brain
                #on test si la proteine est assez proche d'un neurone
                for n in neuron:
                        if self.distance(n)<=self.r+n.r and n.state< 10: #je fixe le maximum de degradation a 10 mais on peut changer
                                n.state+=1
                #mais si une proteine passe sur le neurone, il faut prevoir qu'elle ne se deplacera pas pareil



if __name__=='__main__' :
        p=Protein(5,0,0,60)
        neuron=[n.Neuron(10,20,1)]
        p.degrade(neuron)
        Tprot=[]
        for i in range(10):
                #juste pour tester si les proteines s'accrochent comme il faut
                Tprot.append(Protein(20,i,i,r.randint(0,360)))
        p.run_prot(Tprot)


</code></pre>




      <a id="ancre12"></a>
        <h4 class = "python_class"> La classe Neuron : </h4> <br>
      		<img src="Images/neuron.PNG" width = 10% >


  La classe Neuron possède les attributs suivants :

  <ul class="list">
    <li> x, y et r sont analogues aux attributs éponymes de Protein </li>
    <li> state, l’état du Neuron, entier pouvant varier de 0 à 10, 0 étant un état fonctionnel et 10 non-fonctionnel. En réalité, le choix de l’échelle était encore en réflexion, la prendre de 0 à 10 était temporaire. </li>
  </ul>

<p class="underline"> Méthode : </p><br>

<p> La classe n’avait qu’une méthode : apparition_protein(self, Tprotein). Tprotein est un tableau de protéine. Selon une certaine probabilité, la méthode ajoute une protéine qu’elle crée au tableau ou non.</p>

<h4 class="center"> Visualisation du code Python de la classe <i>Neuron</i> : </h4>

<pre><code class="language-python">
  import time as t
  import random as r
  import proteine as p
  import cerveau as c

  class Neuron():
  	def __init__(self, r, x, y):
  		self.r=r #r est le rayon du neurone
  		self.state=0   #l'etat du neurone qui varie de 0 a... 10 ? 10 est le plus grave
                  #coordonnees du neurone :
  		self.x=x
  		self.y=y
  		self.proteins=[] #tableau de proteines
  		self.color="black"
  	def apparition_protein(self, Tprotein): #fait apparaitre une proteine selon une certaine probabilite
                  if r.random() < 0.1:
                          #ajout d'une proteine de rayon 5 et des memes coordonnes que le neurone, se deplacant dans une direction aleatoire
                          Tprotein.append(p.Protein(Tprotein[0].r, self.x, self.y, r.randint(0,360)))


  if __name__=='__main__' :
          neuron=Neuron(20,5,60)
          brain=c.BrainView(400,400)
          neuron.apparition_proteine(brain)




</code></pre>


      <a id="ancre13"></a>
        <h4 class = "python_class"> La classe BrainView : </h4><br>

<p> Elle hérite de la classe Canvas (de tkinter). Elle possède en plus les attributs suivants : </p>

    <ul class="list">
      <li> neuron : un tableau de Neuron </li>
      <li> TabProtein : un tableau de Protein </li>
    </ul>
    <br>

    <h4 class="center"> Visualisation du code Python de la classe <i>BrainView</i> : </h4>

    <pre><code class="language-python">
      import tkinter as tk
      import time as t
      import neurone as n
      import proteine as p
      import random as r

      class BrainView(tk.Canvas):
        def __init__(self,wi, he):
          self.fenetre=tk.Tk()
          tk.Canvas.__init__(self,self.fenetre,width=wi+50, height=he+50)
          self.pack()
          self.create_rectangle(0,0,wi,he,fill='white')
          self.width=wi
          self.height=he
          self.neuron=[] #definition d'un tableau de neurones
          self.TabProtein=[]#definition d'un tableau de proteines
          self.time=t.time()
        def draw_neurone(self, n):
                      self.create_oval(n.x,n.y,n.x+2*n.r,n.y+2*n.r,fill=n.color)

        def draw_proteins(self, p):
                      self.create_oval(p.x,p.y,p.x+p.r*2,p.y+p.r*2,fill=p.color)

        def run_protein_and_neuron(self): #on fait toutes les actions sur les neurones et proteines
                      for n in self.neuron:
                              n.apparition_protein(self.TabProtein)
                              self.draw_neurone(n)
                      for i in range(len(self.TabProtein)):
                              self.TabProtein[i].detach()
                              for j in range(i+1,len(self.TabProtein)):
                                      self.TabProtein[i].hook(self.TabProtein[j])
                                      self.TabProtein[j].hook(self.TabProtein[i])
                                      self.TabProtein[i].change_state(self.TabProtein[j])
                                      self.TabProtein[j].change_state(self.TabProtein[i])
                              self.TabProtein[i].move(self)
                              self.draw_proteins(self.TabProtein[i])

      def myfunction():
        brain.delete('all') #truc qui efface les objets enregistres par tkinter, ca evite les ralentissements
        brain.create_rectangle(0,0,brain.width, brain.height, fill='white')
        brain.run_protein_and_neuron()
        brain.fenetre.after(1, myfunction) #myfuncton est rappelee toutes les 10 ms


      if __name__=='__main__':
              w=800
              h=800
              brain=BrainView(w,h)
              for _ in range(100):
                      #juste pour tester si les proteines s'accrochent comme il faut
                      brain.TabProtein.append(p.Protein(10,r.randint(300,500),r.randint(300, 500),r.randint(0,360)))
              brain.neuron.append(n.Neuron(50,100,200))
              myfunction()
              brain.fenetre.mainloop()

    </code></pre>


      <a id="ancre14"></a>
        <h4> Difficultés rencontrées et non résolues lors de l’implémentation : </h4>

        <p>
          La difficulté majeure venait de l’agrégation. En effet, les protéines d’un amas doivent se déplacer simultanément. Pour résoudre ce problème, nous avons eu l’idée de considérer une Protein leader qui est suivie par les autres. Ce faisant, nous sommes parvenus à observer des protéines s’agréger. Néanmoins ce n’était pas parfait. Il arrivait que des amas ne s’agrègent pas en se touchant, ou au contraire, qu’ils s’agrègent en ne se touchant pas tout à fait. Les raisons n’étaient pas parfaitement connues mais vraisemblablement liées à l’attribution du leader pour chaque Protein.
          Nous avons eu l’idée d’ajouter une classe Agregat qui puisse résoudre ces problèmes, mais nous n’étions pas certains de son efficacité. Là encore, la confinement ne nous a pas laissé le temps d’explorer plus loin l’idée, ou de retravailler simplement l’attribution du leader chez les protéines. </p>
          <p> Une autre difficulté venait de la mémoire utilisée. En effet, le nombre de protéines étant amené à être imposant, les calculs demandaient du temps. Sur les ordinateurs de l’INSA, cela ne posait pas de problèmes mais sur nos ordinateurs personnels moins puissants, une cinquantaine de protéines commençait à faire beaucoup.</p>



<a id="ancre15"></a>
  <h3 class = "sous-partie">IV- Avec Python 3 : </h3>
<table cellspacing="0" align="center">
<tr>
<th>

          <a id="ancre16"></a>
             <h4 class="center"> Première version  : </h4>
             <video controls width = "400" height ="400">
                <source src="./Videos/Python_Alpha1.webm" type="video/webm">
             </video>
</th>
<th width=200px></th>
<th>
          <a id="ancre17"></a>
             <h4 class="center"> Deuxième version  : </h4>
             <video controls width = "400" height ="400">
                <source src="./Videos/Python_Alpha2.webm" type="video/webm">
             </video>
</th></tr></table>

	<a id="ancre18"></a>

	<p> <br> Remarque : sur ces vidéos, un seul neurone a été implémenté car nous nous concentrions avant tout sur l'agrégation des protéines. Bien sûr, nous aurions rajouté des neurones une fois le code satisfaisant. De plus, la taille des neurones, des protéines, et les probabilités qu'une protéine change d'état étaient fixés arbitrairement pour l'instant. Le paramétrage était prévu une fois le code fonctionnel et à l'aide des modélisations mathématiques que nous allons vous présenter. </p>

</body>
</html>
