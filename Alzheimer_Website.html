<!DOCTYPE html>
<html lang="fr">
  <head>
        <meta charset="UTF-8" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta name="author" content="Maëlle Broustal - Florian Dupeuble - Aurélie Fischer - Nicolas Mendiboure" />
        <meta name="description" content="">

        <title id="Description">La Maladie d'alzheimer - Projet 3BIM</title>

        <link type="text/css" rel="stylesheet" href="Alzheimer_Website.css" />
        <!-- Bootstrap core CSS -->
        <link href="./styles/bootstrap.min.css" rel="stylesheet">
        <!-- jQWidgets CSS -->
        <link href="./jqwidgets/styles/jqx.base.css" rel="stylesheet">
        <link href="./jqwidgets/styles/jqx.bootstrap.css" rel="stylesheet">
        <link href="./prism.css" rel="stylesheet" />
  </head>

	<body>
    <!-- Wrap all page content here -->
    <div id="wrap">
       <!-- Fixed navbar -->
       <div class="navbar navbar-default navbar-fixed-top" role="navigation">
          <div class="container">
             <div style="visibility: hidden;" id="navBar" >
                <ul>
                   <li>
                      <a href="#">Menu</a>
                      <ul style="width: 400px;">
                         <li><a href="#ancre1">Présentation du projet</a></li>
                         <li type="separator"></li>
                         <li><a href="#ancre2">Introduction à la biologie d'Alzheimer</a></li>
                         <li><a href="#ancre3"> - La protéine Béta-Amyloide</a></li>
                         <li><a href="#ancre4"> - La protéine Tau</a></li>
                         <li><a href="#ancre5"> - La formation d'agregats</a></li>
                         <li type="separator"></li>
                         <li><a href="#ancre6"> - Les solutions thérapeutiques existantes</a></li>
                         <li><a href="#ancre7">Modélisations</a></li>
                         <li><a href="#ancre8"> - Utilisation de l'individu centré</a></li>
                         <li><a href="#ancre9"> - Logiciel Netlogo</a></li>
                         <li><a href="#ancre10"> - Passage sur Python</a></li>
                         <li><a href="#ancre11"> - La classe Protein </a></li>
                         <li><a href="#ancre12"> - La classe Neuron </a></li>
                         <li><a href="#ancre13"> - La classe BrainView </a></li>
                         <li><a href="#ancre14"> - Difficultés rencontrées </a></li>
                         <li><a href="#ancre15"> - Avec Python 3</a></li>
                         <li><a href="#ancre16"> - Première version </a></li>
                         <li><a href="#ancre17"> - Duexième version</a></li>


                         <li type="separator"></li>


                         <li><a href="#ancre18">Bibliographie / Sources</a></li>
                         <li type="separator"></li>
                      </ul>
                   </li>
                   <li>
                      <a href="#about">à propos</a>
                      <ul style="width: 400px;">
                         <li>ligne d'explication N°1<br>
                            ligne d'explication N°2
                         </li>
                      </ul>
                   </li>
                   <li>
                      <a href="#contact">Contact</a>
                      <ul style="width: 400px;">
                        <li> 3ème année de bioinformatique </li>
                        <li> Biosciences, INSA Lyon </li>
                        <br>
                        <li>Maëlle Broustal </li>
                        <li> Florian Dupeuble </li>
                        <li> Aurélie Fischer </li>
                        <li> Nicolas Mendiboure </li>


                      </ul>
                   </li>
                </ul>
             </div>
             <!--/.nav-collapse -->
          </div>
       </div>

       <!-- Begin page content -->
                <div class="container">
                   <div class="page-header">
                      <h1>La Maladie d'alzheimer - Projet 3BIM</h1>
                   </div>
                   <a id="ancre1"></a>
                   <p class="lead">
                      <!-- DEBUT CONTENU-->
                   <h2 class="partie">Présentation du projet : </h2>

		<p> Dans le cadre d'un projet annuel au sein de notre département Biosciences de l'INSA Lyon, et plus précisément en accord avec notre parcours d'enseignement Bioinformatique et modélisation (BIM) nous avons choisi d'aborder la maladie d'alzheimer comme thématique centrale autour de laquelle se sont orientées nos rechcerches.
        En effet le but de ce projet est de rassembler, par groupe d'étudiants en 3éme année d'école d'ingénieur, un maximun de connaissances afin de pouvoir modélisser numériquement et mathématiquement un phénomène biologique préalablement étudié.</p>

    <a id="ancre2"></a>
           <h2 class = "partie">Introduction à la biologie d'Alzheimer  </h2>
    <a id="ancre3"></a>
           <h3 class = "sous-partie">La protéine Béta-Amyloide </h3>

			<p> La protéine <b>béta-Amyloid</b> est un peptide de 38 à 43 acides aminés (protéine de petite taille) qui diminuerait la communication synaptique entre les neurones.
          Son action aurait pour effet d'empecher la capture de choline, composant indispensable à la synthèse d'acétylcholine. L'acétylcholine est quant à lui un neurotransmetteur impliqué dans la momorisation.  </p>

			<p> Cette protéine proviendrait du clivage enzymatique de la proteine précurseur de l'amyloide notée APP. Une fois clivée elle peut apparaitre sous deux formes : Aβ42 et Aβ40. C’est Aβ42 qui est remarqué en majorité dans les plaques dans le cerveau d’un malade atteitn d'Alzheimer.
        Il est même possible que dans les agglomérats initiaux de la maladie, seul les Aβ42 soient présentes. Des tests in vitro ont été réalisé, et les chercheurs ne trouvent pas de différence de présence entre les deux formes, il y a donc un mécanisme in vivo - dans le cerveau inconnu qui conduit à une présence plus importante d’Aβ42.
        Il faut également savoir qu'une plus grande toxicité a été observée pour un ratio Aβ42/Aβ40 plus grand. </p>

        <a id="ancre4"></a>
              <h3 class = "sous-partie">
              La protéine Tau </h3>

          <div id="tau">
            <div id="tau_im">
                <img src="Images/Tau.jpg" width=100%>
            </div>
            <div id="tau_text">


      <p> <b>Tau</b>: « Tubulin Associated Unit ».
          Le rôle des Protéines Tau est de participer à l'architecture des neurones et à leur stabilité. Celles-ci associées aux microtubules est la stabilisation de leurs composants au cytosquelette.
          Les microtubules servent à transporter les matériaux synthétisés par le corps cellulaire vers les terminaisons nerveuses et à en maintenir la forme.
          Les pathologies liées à des anomalies de la protéine Tau sont des tauopathies, des démences parmi lesquelles se trouve la maladie d’Alzheimer. Une tauopathie se définit par l'accumulation anormale de protéines Tau.
          Le mauvais fonctionnement des protéines Tau est lié à un excès de phosphorylation (l'ajout de groupements phosphate), entraînant l'agrégation des protéines entre elles : des amas de protéines Tau se forment ; il y a une désorganisation des neurones en une dégénérescence neurofibrillaire, qui peut entraîner la mort cellulaire (dégénérescence cellulaire).
          C'est pourquoi la protéine Tau fait partie des cibles thérapeutiques pour la recherche de nouveaux traitements contre la maladie d'Alzheimer.</p>

          </div>
        </div>

      <p class='small'> <i>Source de l'image:</i> <a href=https://fr.wikipedia.org/wiki/Prot%C3%A9ine_tau> https://fr.wikipedia.org</a></p>
<br> <br> <br> <br> <br>


      <a id="ancre5"></a>
      <h3 class="sous-partie"> La formation d'agregats :  </h3>

      <p> Dans le cas d’alzheimer, la beta amyloïde s’agrège et se dépose sous forme de plaques d’abord dans l’hippocampe (qui joue un rôle dans la mémoire et le repérage spatial) et le lobe temporal (qui joue dans les fonctions du langage, ainsi que de la mémoire).
              Puis il s’agrège dans le lobe frontal (mouvement, langage, planification) et pariétal (intégration des informations).  On ne sait pas si le nombre de plaques formés joue sur la sévérité de la maladie. Ce serait plutôt la perte de synapse au début de la maladie qui serait important. La protéine Tau, quant à elle forme des amas de dégénérescences neurofibrillaires.
      </p>

      <a id="ancre6"></a>
        <h3 class = "sous-partie">Les solutions thérapeutiques existantes  </h3>

<p>
      Aucun traitement ne permet à l’heure actuelle de guérir de la maladie ou de stopper son évolution. Certain médicaments sont toutefois disponibles sur le marché.
      Dans le meilleur des cas (malheureusement trop rares), la famille, le patient et le spécialiste vont constater une amélioration, avec une meilleure qualité de vie et des performances cognitives améliorées.
      Le plus souvent, on observe un ralentissement dans l'évolution de la maladie et une diminution de certains troubles du comportement. </p>
<p>
      Enfin, les thérapies non-médicamenteuses se développent de plus en plus :
      elles permettent d’améliorer le confort et le bien-être des malades et de freiner le développement des troubles. </p>

      <p>
      Deux familles de médicaments sont utilisées pour ralentir le développement des troubles cognitifs associés à la maladie d’Alzheimer : </p>
      <ul class="list">
        <li> Les <b>anticholinestérases : </b> Ces médicaments ont un effet sur l’acétylcholine. Cette substance, qui est fabriquée par les cellules nerveuses et agit sur la mémoire et l’apprentissage, est détruite au cours de la maladie d’Alzheimer.
          Les anticholinestérases ralentissent la destruction de l’acétylcholine, améliorant ainsi le comportement du malade et ses gestes quotidiens. Les anticholinestérases sont prescrits au stade léger et moyen de la maladie ; </li>
        <li> <b>les antiglutamates : </b> Ces molécules agissent sur les récepteurs du glutamate, substance produite en excès par les cellules nerveuses des malades atteints d’Alzheimer, entraînant ainsi la destruction d’autres cellules, les cellules réceptrices.
          Les antiglutamates bloquent l’interaction du glutamate avec les cellules réceptrices, ce qui ralentit la perte de mémoire et le déclin des fonctions cognitives. Les antiglutamates sont prescrits au stade moyen et sévère de la maladie. </li>
      </ul>



      <a id="ancre7"></a>
        <h2 class ="partie">Modélisations </h2>

      <a id="ancre8"></a>
        <h3 class = "sous-partie">I - Choix du type de modélisation : utilisation de l’individu centré </h3>


		<p> Une fois décidé de travailler sur la propagation de la maladie dans le cerveau, nous avons fait de nombreuses recherches sur les modélisations envisageables, notamment sur les modélisations de neurones. Ce qui nous a amené aux réseaux de neurones. Nous avons orienté nos recherches dans cette direction mais nous sommes aperçus que, malgré son nom, cette technique n’est pas nécessairement adaptée pour modéliser le cerveau, sans compter sa complexité.
Etant à court d’idée, nous avons songé à demander de l’aide à des personnes connaissant le sujet. Une chance pour nous : de nombreux professeurs du département Biosciences ont travaillé sur alzheimer. Nous avons contacté Laurent PUJO-MENJOUET que nous connaissions bien. Pendant une discussion, il nous a conseillé de nous tourner vers les modélisation automate-cellulaire et individu centré.
		</p>

    <p>
        La modélisation de l’automate cellulaire présente une grille de cellules pouvant prendre différents états. Leur état est amené à évoluer au cours du temps en répondant à certaines règles (ou fonctions d’état) identiques pour chaque cellule, reliées à l’état de leurs cellules adjacentes. Les règles s’appliquent à chaque itération temporelle.
        Un exemple célèbre de ce type de modélisation est le jeu de la vie. </p>

            <div id="jeu_vie">
              <div id="jeu_vie_video">

                <video controls width = "420" height ="420">
                    <source src="./Videos/Jeu_vie.webm" type="video/webm">
                </video>

                <h5 class="center small"> <b>Vidéo</b> : Exemple de jeu de la vie codé en java (openjdk-11)<h5>

              </div>

              <div id="jeu_vie_text">


    <p>
      Les cellules peuvent prendre deux états distincts : vie ou mort. Les règles sont les suivantes :
      “une cellule morte possédant exactement trois voisines vivantes devient vivante (elle naît) ;
      une cellule vivante possédant deux ou trois voisines vivantes le reste, sinon elle meurt.”
      Malgré sa simplicité, le jeu de la vie intéresse de part les différents comportements pris par les cellules en fonction de l’état initial (structures stables, canons, vaisseaux…)
    </p>

    <p>
      L’individu centré est un système comportant des entités autonomes, ou individus, qui disposent d’informations, que nous appelons perceptions, sur leur environnement de façon localisée. De nouveau, certaines règles sont appliquées, ici aux individus. Elles vont les conduire à une action sur leur environnement.
      Par exemple, il peut s’agir de déplacement ou d’affecter d’autres individus.
      De nombreux exemples existent, bien qu’aucun, sans doute, ne soit aussi célèbre que le jeu de la vie. Citons Mobisim, une modélisation pour l’analyse géographique et la mobilité des hommes.
    </p>

  </div>

</div>



<div class="textblock">
    <p>
      Nous avons choisi l’individu centré. En effet, il nous a semblé plus pertinent de considérer les protéines comme des agents, car celles-ci se déplacent dans le cerveau et s’agrègent. Avec un automate cellulaire, la grille aurait représentée le cerveau.
      Les différents états des cellules auraient été leur niveau de dégradation ou la présence d’agrégat à l’intérieur. Nous aurions assisté à une diffusion de la maladie. Avec une modélisation individu centré, il est à la fois possible d’assister à une diffusion de la maladie, mais en plus d’avoir une idée précise de la façon dont se forment les agrégats.
      Nous pouvions aussi considérer les neurones comme d’autres individus qui produisent des protéines, ou encore d’autres éléments : par exemple, imaginer un produit aux effets diverses sur les protéines (ralentissement, empêchement de s’agréger) et observer les conséquences, ce qui pourrait aider dans la recherche d’un médicament.
      En résumé, l’individu centré nous donnait une plus grande liberté dans la modélisation, c’est pourquoi nous nous sommes tournés vers lui.
     </p>

    <p> Nous avons choisi de nous concentrer sur les protéines beta amyloïdes et laisser de côté les protéines tau. Ainsi, les beta amyloïdes et les neurones seraient les individus de notre modélisation. Quels comportements souhaitions-nous implémenter ? </p>

    <p>
    Les <b> protéines </b> , représentées par des sphères de couleur, sont capables de se déplacer sur le “terrain”, dont nous explicitons les particularités plus loin. Leurs déplacements sont globalement rectilignes mais peuvent comporter de légères courbures aléatoires.
    Elles possèdent une faible <b>probabilité de devenir spontanément infectieuses</b>. Quand elles touchent d’autres protéines, elles se collent à elles et transmettent leur infection le cas échéant.
    Elles possèdent une faible <b>probabilité de se détacher spontanément </b>. Quand elles s’agrègent, leur vitesse de déplacement diminue (plus l’agrégat est important, plus leur vitesse ralentie).
    Quand elles touchent un neurone, elles affectent son état. </p>

    <p>
    Les <b>neurones </b>, également représentés par des sphères, sont immobiles sur le terrain.
    A chaque itération, ils possèdent une <b> probabilité d’expulser </b> une nouvelle protéine beta amyloïde non infectée.
    Ils possèdent une échelle d’états, allant de parfaitement fonctionnels à non fonctionnels. Au départ, ils sont parfaitement fonctionnels. Lorsqu’ils ne sont plus fonctionnels, ils ne peuvent plus expulser de nouvelles protéines. Ce sont les beta amyloïdes qui influencent leur état.
    le terrain Ce que nous appelons le terrain correspond ici à la matrice extracellulaire du cerveau dans laquelle se déplace les protéines. Le problème de conception majeur venait des bords. Nous pouvions les considérer comme des frontières infranchissables  pour les protéines ou au contraire, considérer qu’il ne s’agit que d’une partie du cerveau et que les protéines peuvent s’en”échapper” pour aller dans le reste du cerveau, ou d’autres y parvenir. Le premier cas pose problème d’un point de vue de design : il est difficile d’imaginer que les protéines rencontrent ainsi des murs. Bien que le cerveau soit limité, la taille des protéines est très faible devant le volume du cerveau, et la fréquence de rencontre avec des “murs” est sans doute infime. Le deuxième cas pose problème d’un point de vue implémentation : si nous considérons que les protéines peuvent quitter le terrain de la simulation, nous avons peu de chances de les observer s’agréger (à moins d’une taille de terrain énorme). Même si de nouvelles protéines peuvent entrer sur le terrain, cela ne suffira pas, car le problème vient des agrégats qui quittent le terrain. Nous avons pensé à poser une probabilité qu’un agrégat entre dans le terrain à chaque itération, mais cela allait à l’encontre de l’un des objectifs de notre modélisation : observer comment se forment les agrégats.
    Une solution alternative était de considérer le terrain comme une coupe 2D non plane du cerveau. Prenons l’exemple d’une coupe cylindrique, que nous couperions dans le sens de la hauteur et mettrions à plat.
    </p>

  </div>

  <div id="cylindre">
    <div id="cylindre_im">
        <img src="Images/cylindre.PNG" width = 80% >
    </div>
    <div id="cylindre_text">


    <p>
    Dans ce cas, les protéines allant sur l’un des bords en pointillés se retrouvent de l’autre côté à la même hauteur. Là encore, nous rencontrons un problème de design : est-il vraiment pertinent d’envisager notre terrain comme une coupe non plane du cerveau ?
    En réalité, notre groupe ne tombait pas d’accord sur la meilleure possibilité. Avant que le projet s’interrompe, nous considérions ce dernier cas pour des raisons pratiques, mais ce choix était amené à changer.
    </p>

    <p>
    Nous avons pensé à ajouter des individus correspondants à des substances hypothétiques, qui pourraient par exemple ralentir les beta amyloïdes, afin de découvrir quelles influences seraient bénéfiques de chercher pour un médicament. Néanmoins, nous avons convenu que nous devions d’abord achever la modélisation des éléments précédents avant de rajouter de nouveaux types d’individus, et à condition que le délais restant soit suffisant. L’interruption du projet ne nous en a pas donné le temps.
    </p>

    </div>
  </div>


    <a id="ancre9"></a>
      <h3 class = "sous-partie">II- Avec le logiciel Netlogo : </h3>

    <p>
		Netlogo &copy est un logiciel gratuit et opensource munis de son propre language de programmation ainsi que d'un environnement de modélisation permettant de créér des systèmes multi-agents allant du modèle proies - prédateurs, au modèle simulant la construction d'un nid d'abeille ou bien le développement d'une tumeur. Ce logiciel nous a été suggéré par notre tuteur de projet Mr. Pujo Menjouet. Le gros point fort de NetLogo logo est qu'il est livré avec une très grande bibliothèque de modèles tous aussi variés les uns que les autres, nous permettant ainsi de nous en inspirer afin de ce  très vite comprendre et assimiler la syntaxe du language NetLogo et d'en resortir une ébauche de premier modèle individu-centré, mettant en realtion un neurone et les proteines Amyloid bétas qui s'agregent autour de lui. Un autre point fort de Netlogo est que son interface graphique est très intuitive à utiliser, ainsi il est très simple de mettre en relation le code et l'interface graphique, permettant notament de rajouter ou modifier des paramètres en cours de simulation via l'interface utilisateur grâce à des curseurs ou des boutons.
    </p>


		      <img class="displayed" src="Images/Netlogo_WS.png" width = 60% > <!-- width = 750, height = 650 -->
		      <figcaption class="center"> Exemple de modèle proie - prédateur avec des moutons et des loups. </figcaption>

          <p class='small center'> <i>Source de l'image </i> : <a href=https://ccl.northwestern.edu/netlogo/models/WolfSheepPredation> https://ccl.northwestern.edu/netlogo/</a></p>

<table cellspacing="0" align="center">
    <tr height=50px>  </tr>
    <tr>
      <th>
          <h4 class="center"> Simulation avec NetLogo  : </h4>
      		<video controls width = "800" height ="500">
          		<source src="./Videos/NetLogo.webm" type="video/webm">
      		</video>

        </th>
    </tr>
    <tr height=50px>  </tr>
</table>

<h4 class="center"> Visualisation du code NetLogo &copy; : </h4>

<pre><code class="language-python">
breed [AB a-AB]
breed [neurone a-neurone]
AB-own [leader turn-amount]

to setup
  clear-all
  setup-neurone
  create-AB nb-AB-ini?
    [ set color red
      set shape "circle"
      setxy random-xcor random-ycor
      rt random-float 360
      ;; initially, every node leads its own cluster of one
      set leader self ]
  reset-ticks
end

to go
  ;; All the leaders choose turn amounts
  ask AB with [leader = self] [
    set turn-amount random 10 - random 10
  ]
  ;; All nodes follow their leaders
  ask AB [
    rt [turn-amount] of leader
    fd 0.1
  ]
  ;; Here's the tricky part. We check whether any pairs
  ;; of clusters are touching, and if they are, we merge them.
  ask AB [
    let candidates AB in-radius 1 with [leader != [leader] of myself]
    if any? candidates [
      create-links-with candidates [ hide-link ]
      ask candidates [ merge ]
    ]
  ]
  if random 1000 < 3 [
    create-AB 1 [
      set color yellow
      set shape "circle"
      setxy 0 0
      rt random-float 360
      set leader self
      ]
    ]
  tick
end

;; This is a recursive procedure -- it calls itself.
;; That way the new leader propagates through the entire
;; cluster.
to merge  ;; node procedure
  ;; First this node merges.
  set leader [leader] of myself
  set heading [heading] of leader
  set color blue
  ;; Then any neighboring nodes that haven't merged yet
  ;; merge.
  ask link-neighbors with [leader != [leader] of myself]
    [ merge ]
end

to setup-neurone
  create-neurone 1
  [
    setxy 0 0
    set color blue + 1
    set size 4
    set shape "leaf"
  ]
end
</code></pre>



    <a id="ancre10"></a>
        <h3 class = "sous-partie">III- Passage sur python </h3>

		<p> Nous avons défini trois classes python : la classe Protein, Neuron, et BrainView.</p>

      <a id="ancre11"></a>
        <h4 class = "python_class"> La classe Protein : </h4> <br>
		        <img src="Images/protein.PNG" width = 10% >


<br>

    <p> La classe Protein possède les attributs suivants : </p>
      <ul class="list">
        <li> x et y, ses coordonnées spaciales </li>
          <li>  r, son rayon </li>
            <li> direction, qui correspond à l’angle formé avec l’axe des x de la fenêtre de visualisation dans le sens des aiguilles d’une montre </li>
          <li> leader, qui est la Protein suivie par la Protein courante. Lors de son initialisation, le leader de la Protein est elle-même. L’intérêt de cet attribut, inspiré par l’implémentation sur NetLogo, était d’avoir une Protein qui imposerait la direction à toutes celles dans le même agrégat qu’elle (et qui l’aurait comme leader). </li>
        <li> color, qui correspond à son état : normal ou infectieux. Lors de son initialisation, son état est normal, soit color == “yellow”. Dans son état infectieux, color ==”red” </li>
      </ul>

<br>

<p>
  Parmi les méthodes importantes, on trouve :
  move : modification des x et y de la Protein grâce aux fonctions cos et sin appliquées au leader
  hook : si deux Protein se touchent, elles se collent. L’une devient leader. Nous pensons que les problèmes d’agrégations viennent de là. En effet, lorsque deux agrégats se croisent, il faut que toutes les Protein d’un des agrégats prennent comme leader le leader de l’autre agrégat. Cette attribution n’est pas totale.
  degrade : prend en argument un Neuron. S’ils se touchent, l’état du Neuron gagne 1.
</p>
<pre><code class="language-python">
import math as m
import cerveau as c
import neurone as n
import random as r


class Protein():
	def __init__(self, r, x, y, angle):
		self.r=r #r est le rayon de la proteine
		self.color="yellow"  #deux couleurs possibles : yellow = etat normal,  red = etat infectieux de la proteine
		#coordonnees de la proteine :
		self.x=x
		self.y=y
		self.leader=self #definie le leader (la proteine suivi) comme elle meme
		self.led=self #la protein qui la suit est elle meme
		self.direction=angle #la proteine se deplace selon un angle en degres

	def change_state(self, protein):
                #la proteine a une chance de changer d'etat toute seule et accrue si elle touche une proteine
		if r.random()< 0.0001:
			self.color="red"
		if self.distance(protein)<=self.r+protein.r and protein.color=="red":
                        #si une proteine en touche une autre qui est rouge, elle devient rouge
                        self.color="red"

	def move(self, c):
                if r.random()< 0.000001:
                        self.leader.leader.direction+=r.randint(1,5)
                        self.direction=self.leader.leader.direction
                #la proteine se deplace selon un angle (entier), elle doit suivre le leader
                self.x=self.x+int(10*m.cos(m.degrees(self.leader.leader.direction)))
                self.y=self.y+int(10*m.sin(m.degrees(self.leader.leader.direction)))

                if (self.x < 0) :
                    self.x = c.width
                elif (self.x > c.width) :
                    self.x = 0

                if (self.y < 0) :
                    self.y = c.height
                elif (self.y > c.height) :
                    self.y = 0


	def hook(self, protein):
                #deux proteines (d'etat evil seulement je crois) peuvent s'accrocher
                if self.distance(protein)<=protein.r+self.r :

                        self.leader.leader=protein.leader
                        self.leader=protein.leader
                        self.direction=protein.leader.direction
                        #t'inquietes ca marche
                        #si si je t'assure
                        #aiiiie cooonfiansssssse
                        #En vrai ca marche pas parfaitement bien


	def detach(self):
                #une proteine accrochee ont une probabilite de se decrocher
                #ce qui revient a tranformer le leader en elle meme
                if r.random()< 0.0000000000001:
                        self.leader=self

	def distance(self, cercle): #mesure la distance entre la proteine
                #et une autre proteine ou le neurone
                return m.sqrt((self.x-cercle.x)*(self.x-cercle.x)+(self.y-cercle.y)*(self.y-cercle.y))

	def degrade(self, neuron): #neuron est le tableau de neurones de brain
                #on test si la proteine est assez proche d'un neurone
                for n in neuron:
                        if self.distance(n)<=self.r+n.r and n.state< 10: #je fixe le maximum de degradation a 10 mais on peut changer
                                n.state+=1
                #mais si une proteine passe sur le neurone, il faut prevoir qu'elle ne se deplacera pas pareil



if __name__=='__main__' :
        p=Protein(5,0,0,60)
        neuron=[n.Neuron(10,20,1)]
        p.degrade(neuron)
        Tprot=[]
        for i in range(10):
                #juste pour tester si les proteines s'accrochent comme il faut
                Tprot.append(Protein(20,i,i,r.randint(0,360)))
        p.run_prot(Tprot)


</code></pre>




      <a id="ancre12"></a>
        <h4 class = "python_class"> La classe Neuron : </h4> <br>
      		<img src="Images/neuron.PNG" width = 10% >


  La classe Neuron possède les attributs suivants :

  <ul class="list">
    <li> x, y et r sont analogues aux attributs éponymes de Protein </li>
    <li> state, l’état du Neurone, entier pouvant varier de 0 à 10, 0 étant un état fonctionnel et 10 non-fonctionnel. En réalité, le choix de l’échelle était encore en réflexion, la prendre de 0 à 10 était temporaire. </li>
  </ul>

<p class="underline"> Méthode : </p><br>

<p> La classe n’avait qu’une méthode : apparition_protein(self, Tprotein). Tprotein est un tableau de protéine. Selon une certaine probabilité, la méthode ajoute une protéine qu’elle crée au tableau ou non.</p>

<pre><code class="language-python">
  import math as m
  import cerveau as c
  import neurone as n
  import random as r


  class Protein():
    def __init__(self, r, x, y, angle):
      self.r=r #r est le rayon de la proteine
      self.color="yellow"  #deux couleurs possibles : yellow = etat normal,  red = etat infectieux de la proteine
      #coordonnees de la proteine :
      self.x=x
      self.y=y
      self.leader=self #definie le leader (la proteine suivi) comme elle meme
      self.led=self #la protein qui la suit est elle meme
      self.direction=angle #la proteine se deplace selon un angle en degres

    def change_state(self, protein):
                  #la proteine a une chance de changer d'etat toute seule et accrue si elle touche une proteine
      if r.random()< 0.0001:
        self.color="red"
      if self.distance(protein)<=self.r+protein.r and protein.color=="red":
                          #si une proteine en touche une autre qui est rouge, elle devient rouge
                          self.color="red"

    def move(self, c):
                  if r.random()< 0.000001:
                          self.leader.leader.direction+=r.randint(1,5)
                          self.direction=self.leader.leader.direction
                  #la proteine se deplace selon un angle (entier), elle doit suivre le leader
                  self.x=self.x+int(10*m.cos(m.degrees(self.leader.leader.direction)))
                  self.y=self.y+int(10*m.sin(m.degrees(self.leader.leader.direction)))

                  if (self.x < 0) :
                      self.x = c.width
                  elif (self.x > c.width) :
                      self.x = 0

                  if (self.y < 0) :
                      self.y = c.height
                  elif (self.y > c.height) :
                      self.y = 0


    def hook(self, protein):
                  #deux proteines (d'etat evil seulement je crois) peuvent s'accrocher
                  if self.distance(protein)<=protein.r+self.r :

                          self.leader.leader=protein.leader
                          self.leader=protein.leader
                          self.direction=protein.leader.direction
                          #t'inquietes ca marche
                          #si si je t'assure
                          #aiiiie cooonfiansssssse
                          #En vrai ca marche pas parfaitement bien


    def detach(self):
                  #une proteine accrochee ont une probabilite de se decrocher
                  #ce qui revient a tranformer le leader en elle meme
                  if r.random()< 0.0000000000001:
                          self.leader=self

    def distance(self, cercle): #mesure la distance entre la proteine
                  #et une autre proteine ou le neurone
                  return m.sqrt((self.x-cercle.x)*(self.x-cercle.x)+(self.y-cercle.y)*(self.y-cercle.y))

    def degrade(self, neuron): #neuron est le tableau de neurones de brain
                  #on test si la proteine est assez proche d'un neurone
                  for n in neuron:
                          if self.distance(n)<=self.r+n.r and n.state< 10: #je fixe le maximum de degradation a 10 mais on peut changer
                                  n.state+=1
                  #mais si une proteine passe sur le neurone, il faut prevoir qu'elle ne se deplacera pas pareil



  if __name__=='__main__' :
          p=Protein(5,0,0,60)
          neuron=[n.Neuron(10,20,1)]
          p.degrade(neuron)
          Tprot=[]
          for i in range(10):
                  #juste pour tester si les proteines s'accrochent comme il faut
                  Tprot.append(Protein(20,i,i,r.randint(0,360)))
          p.run_prot(Tprot)




</code></pre>


      <a id="ancre13"></a>
        <h4 class = "python_class"> La classe BrainView : </h4><br>

<p> Elle hérite de la classe Canvas (de tkinter). Elle possède en plus les attributs suivants : </p>

    <ul class="list">
      <li> neuron : un tableau de Neuron </li>
      <li> TabProtein : un tableau de Protein </li>
    </ul>
    <br>

    <pre><code class="language-python">
      import tkinter as tk
      import time as t
      import neurone as n
      import proteine as p
      import random as r

      class BrainView(tk.Canvas):
        def __init__(self,wi, he):
          self.fenetre=tk.Tk()
          tk.Canvas.__init__(self,self.fenetre,width=wi+50, height=he+50)
          self.pack()
          self.create_rectangle(0,0,wi,he,fill='white')
          self.width=wi
          self.height=he
          self.neuron=[] #definition d'un tableau de neurones
          self.TabProtein=[]#definition d'un tableau de proteines
          self.time=t.time()
        def draw_neurone(self, n):
                      self.create_oval(n.x,n.y,n.x+2*n.r,n.y+2*n.r,fill=n.color)

        def draw_proteins(self, p):
                      self.create_oval(p.x,p.y,p.x+p.r*2,p.y+p.r*2,fill=p.color)

        def run_protein_and_neuron(self): #on fait toutes les actions sur les neurones et proteines
                      for n in self.neuron:
                              n.apparition_protein(self.TabProtein)
                              self.draw_neurone(n)
                      for i in range(len(self.TabProtein)):
                              self.TabProtein[i].detach()
                              for j in range(i+1,len(self.TabProtein)):
                                      self.TabProtein[i].hook(self.TabProtein[j])
                                      self.TabProtein[j].hook(self.TabProtein[i])
                                      self.TabProtein[i].change_state(self.TabProtein[j])
                                      self.TabProtein[j].change_state(self.TabProtein[i])
                              self.TabProtein[i].move(self)
                              self.draw_proteins(self.TabProtein[i])

      def myfunction():
        brain.delete('all') #truc qui efface les objets enregistres par tkinter, ca evite les ralentissements
        brain.create_rectangle(0,0,brain.width, brain.height, fill='white')
        brain.run_protein_and_neuron()
        brain.fenetre.after(1, myfunction) #myfuncton est rappelee toutes les 10 ms


      if __name__=='__main__':
              w=800
              h=800
              brain=BrainView(w,h)
              for _ in range(100):
                      #juste pour tester si les proteines s'accrochent comme il faut
                      brain.TabProtein.append(p.Protein(10,r.randint(300,500),r.randint(300, 500),r.randint(0,360)))
              brain.neuron.append(n.Neuron(50,100,200))
              myfunction()
              brain.fenetre.mainloop()

    </code></pre>

  </td>

  <td>
    <pre><code class="language-python">
      import time as t
      import random as r
      import proteine as p
      import cerveau as c

      class Neuron():
        def __init__(self, r, x, y):
          self.r=r #r est le rayon du neurone
          self.state=0   #l'etat du neurone qui varie de 0 a... 10 ? 10 est le plus grave
                      #coordonnees du neurone :
          self.x=x
          self.y=y
          self.proteins=[] #tableau de proteines
          self.color="black"
        def apparition_protein(self, Tprotein): #fait apparaitre une proteine selon une certaine probabilite
                      if r.random() < 0.1:
                              #ajout d'une proteine de rayon 5 et des memes coordonnes que le neurone, se deplacant dans une direction aleatoire
                              Tprotein.append(p.Protein(Tprotein[0].r, self.x, self.y, r.randint(0,360)))


      if __name__=='__main__' :
              neuron=Neuron(20,5,60)
              brain=c.BrainView(400,400)
              neuron.apparition_proteine(brain)
    </code></pre>


      <a id="ancre14"></a>
        <h4> Difficultés rencontrées et non résolues lors de l’implémentation : </h4>

        <p>
          La difficulté majeure venait de l’agrégation. En effet, les protéines d’un amas doivent se déplacer simultanément. Pour résoudre ce problème, nous avons eu l’idée de considérer une Protein leader qui est suivie par les autres. Ce faisant, nous sommes parvenus à observer des protéines s’agréger, néanmoins ce n’était pas parfait. Il arrivait que des amas ne s’agrègent pas en se touchant ou au contraire, qu’ils s’agrègent en ne se touchant pas tout à fait. Les raisons n’étaient pas parfaitement connues mais vraisemblablement liées à l’attribution du leader pour chaque protein.
          Nous avons eu l’idée d’ajouter une classe Agregat qui puisse résoudre ces problèmes, mais nous n’étions pas certains de son efficacité. Là encore, la confinement ne nous a pas laissé le temps d’explorer plus loin l’idée, ou de retravailler simplement l’attribution du leader chez les protéines. </p>
          <p> Une autre difficulté venait de la mémoire utilisée. En effet, le nombre de protéine étant amené à être imposant, les calculs demandaient du temps. Sur les ordinateurs de l’INSA, cela ne posait pas de problèmes mais sur nos ordinateurs personnels moins puissants, une cinquantaine de protéine commençait à faire beaucoup.</p>



<a id="ancre15"></a>
  <h3 class = "sous-partie">IV- Avec Python 3 : </h3>
<table cellspacing="0" align="center">
<tr>
<th>

          <a id="ancre16"></a>
             <h4 class="center"> Première version  : </h4>
             <video controls width = "400" height ="400">
                <source src="./Videos/Python_Alpha1.webm" type="video/webm">
             </video>
</th>
<th width=200px></th>
<th>
          <a id="ancre17"></a>
             <h4 class="center"> Deuxième version  : </h4>
             <video controls width = "400" height ="400">
                <source src="./Videos/Python_Alpha2.webm" type="video/webm">
             </video>
</th></tr></table>

    <a id="ancre18"></a>
			<h2> <i> Bibliographie / sources :  </i> </h2>
      <p class='small'> <a href=http://www.maisons-de-retraite.fr/La-sante-des-seniors/Maladie-d-Alzheimer/Quels-sont-les-traitements-de-la-maladie-d-Alzheimer>
                                http://www.maisons-de-retraite.fr/La-sante-des-seniors/Maladie-d-Alzheimer/Quels-sont-les-traitements-de-la-maladie-d-Alzheimer</a>
    <!-- FIN CONTENU-->
  </p>
</div>
</div>

<div id="footer">
  <p> &copy; Maëlle Broustal - Florian Dupeuble - Aurélie Fischer - Nicolas Mendiboure </p>
  <h4> Nous contacter :</h4>
  <p><a href="mailto:votrenom@bidule.com">Envoyez nous un email !</a></p>

</div>
<!-- Bootstrap core JavaScript
================================================== -->
<!-- Placed at the end of the document so the pages load faster -->
<script type="text/javascript" src="./scripts/jquery-1.12.4.min.js"></script>
<script src="./scripts/bootstrap.min.js"></script>
<!-- jQWidgets JavaScript files -->
<script src="./jqwidgets/jqxcore.js"></script>
<script src="./jqwidgets/jqxmenu.js"></script>
<script type="text/javascript">
$(document).ready(function () {
   $("#navBar").jqxMenu({ autoSizeMainItems: true, theme: "bootstrap", showTopLevelArrows: true, width: '100%' });
   $("#navBar").css("visibility", "visible");
});
</script>

  <script src="prism.js"></script>

  </body>
</html>
